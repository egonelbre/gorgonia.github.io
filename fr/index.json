[{"uri":"https://gorgonia.org/fr/reference/exprgraph/","title":"Graph / Exprgraph","tags":[],"description":"","content":"Beaucoup de choses ont été dites sur les graphes de calcul ou sur les graphes d\u0026rsquo;expression. Mais qu\u0026rsquo;est-ce donc en fait? Considérez les comme des AST (arbres d\u0026rsquo;expression syntaxique) pour l\u0026rsquo;expression de façon mathématique de ce que vous voulez. Voici pour exemple un graphe (mais avec un vecteur et une addition scalaire à la place):\nGorgonia permet de présenter les capacités avec un graphe agréable. Voici par exemple le graphe de l\u0026rsquo;équation $y = x^2$ et sa dérivation:\nLire le graphe est chose facile. L\u0026rsquo;expression est construite de bas en haut, pendant que les dérivations sont construites de haut en bas. De cette façon, la dérivative de chaque noeud est grossièrement au même niveau.\nLe marquage en rouge autour d\u0026rsquo;un noeud indique qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un noeud principal. Les noeuds en coloris vert sont des noeuds feuille. Les noeuds avec un fond jaune sont des noeuds d\u0026rsquo;entrée. Les flèches pointillées indiquent quel noeud est le noeud gradient pour le noeud pointé.\nConcrétement, ça indique que c42011e840 ($\\frac{\\partial{y}}{\\partial{x}}$) est le noeud gradient pour l\u0026rsquo;entrée c42011e000 (qui est $x$).\n"},{"uri":"https://gorgonia.org/fr/tutorials/hello-world/","title":"Hello World","tags":[],"description":"","content":" Ceci est un tutoriel étape par étape pour réaliser des oprations très simples avec Gorgonia.\nNotre objectif est d\u0026rsquo;utiliser toute la mécanique de Gorgonia pour réaliser une opération très simple :\n$ f(x,y) = x + y $\navec x = 2 et y = 5\nComment ça marche ? L\u0026rsquo;équation x + y = z peut être représentée graphiquement :\ngraph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y  Pour en obtenir le résultat, nous avons besoin de 4 étapes :\n Réaliser un graphique similaire avec Gorgonia Attribuer des valeurs aux points x et y Instancier un graphique sur un gorgonia vm Extraire la valeur du point z *  Créer un graphique Créer une expression graphique vide avec cette méthode :\ng := gorgonia.NewGraph() Créer les points Nous allons créer des points et les associer à l\u0026rsquo;ExprGraph.\nvar x, y, z *gorgonia.Node Créer l\u0026rsquo;espace réservé x et y sont des variables scalaires, nous pouvons créer le point correspond de la manière suivante:\nx = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) les fonctions prennent pour argument l\u0026rsquo;Exprgraph ; le point ainsi généré est automatiquement associé au graphique.\n Il faut à présent créer l\u0026rsquo;opérateur d\u0026rsquo;addition ; cet opérateur nécessite deux points et renvoie un nouveau point \u0026lsquo;z\u0026rsquo;:\nif z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } le point z renvoyé est ajouté au graphique même si g n\u0026rsquo;a pas été transmis à z ou à la fonction Add (addition).\n Définir les valeurs Nous avons une ExprGraph qui représente l\u0026rsquo;équation z = x + y. À présent, il est temps d\u0026rsquo;attribuer des valeurs à x et y.\nNous utilisons la fonction Let :\ngorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) Activer le graphique Pour lancer le graphique et calculer le résultat, il faut instancier une VM. Utilisons la TapeMachine:\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() et lancer le graphique :\nif err = machine.RunAll(); err != nil { log.Fatal(err) } s\u0026rsquo;il faut lancer le graphique une deuxième fois, il faut utiliser le Reset() du vm : machine.Reset()\n Obtenir le résultat À présent, le point z contient le résultat. Nous pouvons extraire sa valeur en utilisant Value() :\nfmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) nous pourrions aussi accéder à la valeur cachée \u0026ldquo;Go\u0026rdquo; en faisant un appel à z.Value().Data() ce qui renverrait un interface{} contenant un float64 dans le cas présent\n Résultat final package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) }$ go run main.go 4.5"},{"uri":"https://gorgonia.org/fr/getting-started/","title":"Premiers pas","tags":[],"description":"Démarrer rapidement avec Gorgonia","content":" Obtenir Gorgonia Gorgonia est go-gettable et supporte les go-modules. Pour récupérer la bibliothèque ainsi que ses dépendances, il suffit d\u0026rsquo;exécuter:\n$ go get gorgonia.org/gorgonia Premier programme pour faire un calcul simple Créer ce programme simple dans un fichier main.go pour vérifier que tout est correctement installé:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) } Exécuter le programme devrait afficher le résultat 4.5.\nPour plus d\u0026rsquo;explications sur le fonctionnement, veuillez consulter le tutoriel Hello World.\n"},{"uri":"https://gorgonia.org/fr/about/","title":"Fonctionnement de Gorgonia","tags":[],"description":"Suite d&#39;articles pour expliquer le fonctionnement de Gorgonia","content":" À propos Gorgonia fonctionne en créant un graphe de calcul et en l\u0026rsquo;exécutant. C\u0026rsquo;est en quelque sorte un langage de programmation, mais limité aux fonctions mathématiques sans capacité de branche (pas d\u0026rsquo;instructions conditionnelles if/else ou de boucles). C\u0026rsquo;est le paradigme dominant que l\u0026rsquo;utilisateur doit avoir en tête. Le graphe de calcul est un AST.\nCNTK de Microsoft, avec le BrainScript, représente probablement le meilleur exemple de cette idée que construire et exécuter le graphe sont deux choses distinctes. L\u0026rsquo;utilisateur dois penser différemment la construction du graphe et son exécution.\nCependant que l\u0026rsquo;implémentation utilisée par Gorgonia ne force pas la séparation des choses de manière aussi poussée que Brainscript.\nPour aller plus loin Ce chapitre contient des articles ayant pour but d\u0026rsquo;expliquer comment Gorgonia fonctionne.\nLes articles de cette section focus surla compréhension des choses. Chaque article est auto suffisant et fournit le context nécessaire à la compréhension.\n  "},{"uri":"https://gorgonia.org/fr/tutorials/","title":"Tutoriels","tags":[],"description":"Tutoriels sur quelques cas d&#39;usage","content":" Tutoriels tutoriels pour démarrer sur quelques cas d\u0026rsquo;usage de Gorgonia.\nCes tutoriels:\n sont orientés apprentissage sont une introduction pour les nouveaux venus. sont une leçon  Analogie: apprendre à un enfant à cuisines\nListe des tutoriels disponibles  Hello World   Régression linéaire multivariée sur le dataset Iris   "},{"uri":"https://gorgonia.org/fr/how-to/","title":"Guide pratique","tags":[],"description":"Plusieurs guides pratiques pour résoudre un problème précis avec Gorgonia","content":"Comment faire du machine-learning avec Gorgonia ?\nDans cette section, vous verrez comment Gorgonia peut être utilisé pour résoudre différents problèmes.\nCes guides pratiques :\n sont droit au but expliquent comment résoudre un problème précis se composent d\u0026rsquo;étapes compréhensibles  Analogie : une recette dans un livre de recettes\n Résoudre des problèmes de GPU   Dessiner le ExprGraph avec Graphviz (dot)   Créer un tensor depuis un Dataframe (gota)   Sauver les matrices de poids   Comment calculer le gradient (dérivation)   "},{"uri":"https://gorgonia.org/fr/how-to/troubleshoot-gpu-issues/","title":"Résoudre des problèmes de GPU","tags":[],"description":"","content":" Ce document est une liste de conseils en cas de problème. Si vous rencontrez des difficultés en utilisant des GPUs, ce document devrait pouvoir vous aider.\nLe package cu fonctionne avec une application appelée cudatest qui devrait être utile pour résoudre des problèmes.\nPour installer cudatest, lancez :\ngo install gorgonia.org/cu/cmd/cudatest Cela implique que vous ayez déjà installé CUDA, et cuDNN.\nErreur d\u0026rsquo;initalisation avec plusieurs GPUs Si vous utilisez plusieurs GPUs, vous pourriez tomber sur un message qui ressemble à ce qui suit :\nError in initialization, please refer to \u0026#34;https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__INITIALIZE.html\u0026#34; Cela signifie généralement que l\u0026rsquo;une de vos GPUs ne supporte pas CUDA. Vous pouvez tout de même utiliser CUDA si vous savez qu\u0026rsquo;au moins une de vous GPUs supporte CUDA.\nD\u0026rsquo;abord, utilisez nvidia-smi pour trouver les GPUs utilisées. Voici un exemple ci-dessous.\nThu Jul 16 17:41:10 2020 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.51.05 Driver Version: 450.51.05 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla K20Xm On | 00000000:06:00.0 Off | 0 | | N/A 33C P8 16W / 235W | 0MiB / 5700MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ | 1 GeForce GT 1030 On | 00000000:07:00.0 On | N/A | | 35% 33C P0 N/A / 30W | 656MiB / 1994MiB | 51% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | 1 N/A N/A XXXX G /usr/lib/xorg/Xorg 270MiB | | 1 N/A N/A XXXX G /usr/bin/PROGRAMNAME 77MiB | | 1 N/A N/A XXXX G /usr/bin/PROGRAMNAME 68MiB | | 1 N/A N/A XXXX G ...AAAAAAAAA= --shared-files 221MiB | +-----------------------------------------------------------------------------+ Ici, on voit qu\u0026rsquo;il y a deux GPUs :\n GPU ID 0 est Tesla K20Xm. GPU ID 1 est GeForce GT 1030.  La GeForce GT 1030 ne supporte pas CUDA. Alors que la Tesla K20Xm, si. Pour résoudre ce problème, ajoutez simplement cette variable d\u0026rsquo;environnement :\nCUDA_VISIBLE_DEVICES=0 cudatest Cela devrait vous renvoyer quelque chose comme ça :\n$ CUDA_VISIBLE_DEVICES=0 cudatest CUDA version: 11000 CUDA devices: 1 Device 0 ======== Name : \u0026#34;Tesla K20Xm\u0026#34; Clock Rate: 732000 kHz Memory : 5977800704 bytes Compute : 3.5"},{"uri":"https://gorgonia.org/fr/getting-started/ubiquitous-language/","title":"Language dédié et glossaire","tags":[],"description":"","content":" Cette page contient diverses définitions et un glossaire vous permettant de comprendre Gorgonia et de communiquer avec l\u0026rsquo;équipe (via PR ou issues).\nTenseurs  inner(most) dimension(s) (dimensions intérieures (maximales))- pour une forme donnée, les dimensions intérieures tendent vers la droite. Par exemple, dans une forme (2,3,4), les dimensions intérieures sont (3, 4). La dimension intérieure maximale est 4. outer(most) dimension(s) (dimensions exérieures (maximales))- Pour une forme donnée, les dimensions extérieures tendent vers la gauche. Par exemple, dans une forme (2,3,4), les dimensions extérieures sont (2, 3). La dimension extérieure maximale est 2. vector (vecteur) - pour un tenseur de rang 1; par exemple (2), (3) \u0026hellip; les vecteurs vont s\u0026rsquo;écrire [...] column vector (or colvec) (colonnes de vecteurs) -un tenseur de rang 2 (par exemple une matrice) avec des dimensions intérieures comme 1, par exemple (2, 1), (3, 1)\u0026hellip; row vector (vecteur de ligne) - un tenseur de rang 2 (par exemple une matrice) avec la dimension extérieure 1; par exemple (1, 2), (1, 3)\u0026hellip; matrix (matrice) un tenseur de rang -2, avec des dimensions intérieures et extérieures aléatoires; par exemple (1, 2), (2, 1), (2, 3)\u0026hellip; les matrices vont être notées en écriture intégrale dans ce doc. Ceci inclut les vecteurs colonnes et les vecteurs lignes.  "},{"uri":"https://gorgonia.org/fr/getting-started/contributing-doc/","title":"Commencer à contribuer à la documentation","tags":[],"description":"","content":" Si vous souhaitez commencer à contribuer à la documentation de Gorgonia, cette page et ses points liés peuvent vous aider. Pas besoin d\u0026rsquo;être un développeur ou un rédacteur technique pour avoir un grand impact sur la documentation de Gorgonia et l\u0026rsquo;expérience utilisateur ! Pour les points de cette page, il vous suffit d\u0026rsquo;avoir un compte GitHub et un navigateur internet.\nSi vous cherchez des informations sur comment contribuer aux dépôts de code de Gorgonia, consultez les directives de contribution.\nLes bases de la documentation La documentation de Gorgonia est écrite en Markdown et traitée avec Hugo. Sa source est sur GitHub à ce lien https://github.com/gorgonia/gorgonia.github.io. La plupart de la source de la documentation est située dans /content/.\nVous pouvez signaler les problèmes, modifier le contenu et examiner les modifications des autres, le tout à partir du site web GitHub. Vous pouvez également utiliser l\u0026rsquo;historique intégré et les outils de recherche de GitHub.\nMise en page de la documentation La documentation suit la mise en page décrite dans l\u0026rsquo;article Ce que personne ne vous dit sur la documentation.\nElle est divisée en 4 sections. Chaque section est un sous-répertoire dans le directoire content/ du dépôt.\nLes tutoriels Un tutoriel :\n est orienté sur l\u0026rsquo;apprentissage aide un débutant à commencer est une leçon  Analogie: ça doit être comme apprendre à un enfant à cuisiner\nSources du contenu dans le dépôt : content/tutorials\nLes guides HOW-TO Un guide how-to :\n est orienté sur un objectif montre comment résoudre un problème précis est une série d\u0026rsquo;étapes  Analogie: comme une recette dans un livre de cuisine\nSources du contenu dans le dépôt : content/how-to\nLes explications Une explication :\n est orientée sur la compréhension explique apporte du contexte  Analogie : un article sur l\u0026rsquo;histoire sociale culinaire\nSources du contenu dans le dépôt : content/about\nLes références Un guide de référence :\n est orienté sur l\u0026rsquo;information décrit les mécanismes est précis et complet  Analogie : un article d\u0026rsquo;encyclopédie de référence\nSources du contenu dans le dépôt : content/reference\nPlusieurs langues La source de documentation est disponible en plusieurs langues dans / content /. Chaque page peut être traduite dans n\u0026rsquo;importe quelle langue en ajoutant un code à deux lettres déterminé par la norme ISO 639-1. Un fichier sans suffixe est par défaut en anglais.\nPar exemple, la documentation française d\u0026rsquo;une page s\u0026rsquo;appelle page.fr.md.\nAméliorer la documentation Corriger un contenu existant Vous pouvez améliorer la documentation en corrigeant un bug ou une faute de frappe dans la doc. Pour améliorer le contenu existant, vous déposez une _pull request (PR) _ après avoir créé une _fourche (fork) _. Ces deux termes sont spécifiques à GitHub. Pour les besoins de cette rubrique, vous n\u0026rsquo;avez pas besoin de tout savoir à leur sujet, car vous pouvez tout faire à l\u0026rsquo;aide de votre navigateur Web.\nCréer de nouveaux contenus  Les sources du référentiel sont conservées dans la branche develop. Par conséquent, créez votre nouvelle branche dans develop et la PR doit également pointer vers cette branche.\n Pour créer un nouveau contenu, merci de créer une nouvelle page dans le directoire correspondant au sujet de la doc (voir le paragraphe Mise en page de la documentation)\nSi vous avez hugo localement, vous pouvez créer une nouvelle page avec :\nhugo new content/about/mypage.md sinon, veuillez créer une nouvelle page avec un en-tête qui ressemble à :\n---title:\u0026#34;The title of the page\u0026#34;date:2020-01-31T14:59:03+01:00draft:false--- your content Ensuite, soumettez une PR comme expliqué ci-dessous.\nSoumettre une pull request (PR) Suivez ces étapes pour soumettre une PR afin d\u0026rsquo;améliorer la documentation de Gorgonia.\n Sur la page où vous voyez l\u0026rsquo;issue, cliquez sur l\u0026rsquo;icône \u0026ldquo;modifier cette page\u0026rdquo; en haut à droite. Une nouvelle page GitHub apparaît, avec un texte d\u0026rsquo;aide. Si vous n\u0026rsquo;avez jamais créé de fork du référentiel de documentation Gorgonia, vous êtes invité à le faire. Créez le fork sous votre nom d\u0026rsquo;utilisateur GitHub, plutôt que sous celui d\u0026rsquo;une autre organisation dont vous pouvez être membre. Le fork a généralement une URL type https://github.com/ \u0026lt;username\u0026gt; / website, sauf si vous avez déjà un référentiel avec un nom en conflit.\nLa raison pour laquelle vous êtes invité à créer un fork est que vous n\u0026rsquo;avez pas accès aux droits pour créer une branche directement dans le référentiel Gorgonia définitif.\n L\u0026rsquo;éditeur GitHub Markdown apparaît avec le fichier Markdown source. Faites vos changements. Sous l\u0026rsquo;éditeur, remplissez le formulaire ** Propose file change **. Le premier champ est le résumé de votre message de validation et ne doit pas contenir plus de 50 caractères. Le deuxième champ est facultatif, mais peut inclure plus de détails le cas échéant. Cliquez sur ** Propose file change **. La modification est enregistrée en tant que commit dans une nouvelle branche de votre fork, qui est automatiquement nommée quelque chose comme patch-1.\n  N\u0026rsquo;incluez pas de références à d\u0026rsquo;autres isuues GitHub ou pull requests dans votre message de validation. Vous pouvez les ajouter à la description de la pull request plus tard.\n  L\u0026rsquo;écran suivant résume les modifications que vous avez apportées, en comparant votre nouvelle branche (les cases de sélection head fork et compare) à la base fork et base de la branche actuelle (develop dans le référentiel gorgonia/gorgonia.github.io par défaut). Vous pouvez modifier n\u0026rsquo;importe quelle boîte de sélection, mais ne le faites pas maintenant. Jetez un œil au visualisateur de différences en bas de l\u0026rsquo;écran, et si tout semble correct, cliquez sur Create pull request.  Si vous ne souhaitez pas créer la pull request maintenant, vous pouvez le faire plus tard, en accédant à l\u0026rsquo;URL principale du référentiel du site Web Gorgonia ou le référentiel de votre fork. Le site Web GitHub vous invite à faire une pull request s\u0026rsquo;il détecte que vous avez poussé une nouvelle branche vers votre fork.\n  L\u0026rsquo;écran Open a pull request apparaît. L\u0026rsquo;objet de la pull request est le même que le résumé du commit, mais vous pouvez le modifier si nécessaire. le Le corps est rempli par votre message de validation (si présent) et du texte du modèle. Lisez le texte du modèle et remplissez les détails qu\u0026rsquo;il demande, puis supprimez le texte du modèle en trop. Si vous ajoutez fixes #\u0026lt;000000\u0026gt; ou closes #\u0026lt;000000\u0026gt; à la description, avec #\u0026lt;000000\u0026gt; le numéro de l\u0026rsquo;issue associée, GitHub fermera automatiquement l\u0026rsquo;issue lors de l\u0026rsquo;intégration de la PR. Laissez la case Allow edits from maintainers sélectionnée. Cliquez sur Create pull request.\nFélicitations ! Votre pull request est disponible dans Pull requests.\n  Veuillez limiter vos pull requests à une langue par PR. Par exemple, si vous devez apporter une modification identique au même bout de code dans plusieurs langues, ouvrez une PR distincte pour chaque langue.\n  Attendez une relecture. Si un relecteur vous demande de faire une modification, vous pouvez ouvrir l\u0026rsquo;onglet Files changed et cliquer sur l\u0026rsquo;icône crayon ou n\u0026rsquo;importe quel fichier concerné par la pull request. Quand vous sauvegardez le fichier modifié, un nouveau commit est créé dans la branche de la pull request. Si vous attendez qu\u0026rsquo;un relecteur relise les modifications, relancez-le tous les 7 jours. Vous pouvez aussi accéder à la chaîne #gorgonia sur gopherslack, bon endroit pour demander de l\u0026rsquo;aide sur les relectures de PR.\n Si votre modification est acceptée, un réviseur valide votre pull request et le le changement se fait en direct sur le site Web de Gorgonia quelques minutes plus tard.\n  Ce n\u0026rsquo;est qu\u0026rsquo;une manière de soumettre une pull request. Si vous êtes déjà un utilisateur avancé de GitHub, vous pouvez utiliser une interface graphique locale ou un client Git en ligne de commande au lieu d\u0026rsquo;utiliser l\u0026rsquo;interface utilisateur de GitHub.\n"},{"uri":"https://gorgonia.org/fr/how-to/dot/","title":"Dessiner le ExprGraph avec Graphviz (dot)","tags":[],"description":"","content":"Le package encoding de Gorgonia contient une fonction permettant de déployer le ExprGraph en dot language.\nCela permet d\u0026rsquo;utiliser le programme graphviz pour générer des versions png ou svg du graphique.\nUne manière simple de le faire :\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; \u0026#34;gorgonia.org/gorgonia/encoding/dot\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y *gorgonia.Node // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) gorgonia.Add(x, y) b, err := dot.Marshal(g) if err != nil { log.Fatal(err) } fmt.Println(string(b)) } Lancer ce programme et mettre ce qu\u0026rsquo;il renvoie dans le dot process permet d\u0026rsquo;obtenir une image.\npar exemple :\n$ go run main.go | dot -Tsvg \u0026gt; dot-example.svg donne ce graphique :\n"},{"uri":"https://gorgonia.org/fr/tutorials/iris/","title":"Régression linéaire multivariée sur le dataset Iris","tags":[],"description":"","content":" A propos Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.\nLe but de ce tutoriel est de prédire l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction de ses caractéristiques:\n sepal_length // longueur du sépale sepal_width // largeur du sépale petal_length // longueur du pétale petal_width // largeurdu pétale  Les espèces que nous voulons prédire sont:\n setosa virginica versicolor  Le but de ce tutoriel est de programmer Gorgonia pour qu\u0026rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs et le spécimen. À la fin, nous écrirons un utilitaire CLI (autonome) dont l\u0026rsquo;interface sera la suivante:\n./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa Ce tutoriel est à vocation académique. Son but est de décrire comment réaliser une régression linéaire multivariée avec Gorgonia; Ainsi, le modèle utilisé n\u0026rsquo;est pas la meilleur réponse à ce problème particulier.\n Représentation Mathématique Nous considérons que l\u0026rsquo;espèce d\u0026rsquo;une Iris est fonction de la longueur et de la largeur de son sépale ainsi que de la longueur et de la largeur de son pétale.\nPar conséquent, soit $y$ une valeur représentant l\u0026rsquo;espèce, l\u0026rsquo;équation que nous essayons de résoudre est:\n$$ y = \\theta_0 + \\theta_1 * sepal\\_length + \\theta_2 * sepal\\_width + \\theta_3 * petal\\_length + \\theta_4 * petal\\_width$$\nConsidérons à présent les vecteurs $x$ et $\\Theta$ suivants:\n$$ x = \\begin{bmatrix} sepal\\_length \u0026amp; sepal\\_width \u0026amp; petal\\_length \u0026amp; petal\\_width \u0026amp; 1\\end{bmatrix}$$\n$$ \\Theta = \\begin{bmatrix} \\theta_4 \\theta_3 \\theta_2 \\theta_1 \\theta_0 \\end{bmatrix} $$\nNous pouvons réécrire l\u0026rsquo;équation:\n$$y = x\\cdot\\Theta$$\nRégression linéaire Pour trouver les bonnes valeurs de $\\Theta$ rendant l\u0026rsquo;équation vraie pour la majorité des Iris, nous allons utiliser une régression linéaire.\nNous allons encoder les données d\u0026rsquo;entrainement (les constats fait sur plusieurs fleurs) dans une matrice $X$. $X$ est composée de 5 colonnes: sepal length, sepal width, petal length, petal width et une colonne contenant 1 pour le biais. Chaque ligne de la matrice représente une fleur.\nNous allons encoder les espèces dans un vecteur colonne $Y$ composé de nombres flottants.\n setosa = 1.0 virginica = 2.0 versicolor = 3.0  Lors de la phase d\u0026rsquo;apprentissage, le coût est exprimé de la manière suivante:\n$cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$\nNous allons utiliser la méthode de descente de gradient pour optimiser le coût et obtenir les valeurs optimales de $\\Theta$.\nIl est possible d\u0026rsquo;avoir les valeurs exactes de $\\Theta$ (celle qui minimisent le coût) en utilisant l\u0026rsquo;équation normale: $$ \\theta = \\left( X^TX \\right)^{-1}X^TY $$ Vous trouverez sur ce gist une implémentation basique de la solution réalisée avec Gonum.\n Génération des données d\u0026rsquo;entrainement avec gota (dataframe) Tout d\u0026rsquo;abord, générons les données d\u0026rsquo;entrainement. Nous utiliserons un dataframe pour nous simplifier la tâche.\nCe howto donne plus d\u0026rsquo;informations sur l\u0026rsquo;utilisation du dataframe\n func getXYMat() (*mat.Dense, *mat.Dense) { f, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) xDF := df.Drop(\u0026#34;species\u0026#34;) toValue := func(s series.Series) series.Series { records := s.Records() floats := make([]float64, len(records)) for i, r := range records { switch r { case \u0026#34;setosa\u0026#34;: floats[i] = 1 case \u0026#34;virginica\u0026#34;: floats[i] = 2 case \u0026#34;versicolor\u0026#34;: floats[i] = 3 default: log.Fatalf(\u0026#34;unknown iris: %v\\n\u0026#34;, r) } } return series.Floats(floats) } yDF := df.Select(\u0026#34;species\u0026#34;).Capply(toValue) numRows, _ := xDF.Dims() xDF = xDF.Mutate(series.New(one(numRows), series.Float, \u0026#34;bias\u0026#34;)) fmt.Println(xDF.Describe()) fmt.Println(yDF.Describe()) return mat.DenseCopyOf(\u0026amp;matrix{xDF}), mat.DenseCopyOf(\u0026amp;matrix{yDF}) } Cette fonction retourne deux matrices que nous pourrons utiliser avec Gorgonia.\nCreation de l\u0026rsquo;ExprGrap L\u0026rsquo;équation $X\\cdot\\Theta$ est encodée en tant qu\u0026rsquo;ExprGraph:\nfunc getXY() (*tensor.Dense, *tensor.Dense) { x, y := getXYMat() xT := tensor.FromMat64(x) yT := tensor.FromMat64(y) // Get rid of the last dimension to create a vector \ts := yT.Shape() yT.Reshape(s[0]) return xT, yT } func main() { xT, yT := getXY() g := gorgonia.NewGraph() x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y := gorgonia.NodeFromAny(g, yT, gorgonia.WithName(\u0026#34;y\u0026#34;)) theta := gorgonia.NewVector( g, gorgonia.Float64, gorgonia.WithName(\u0026#34;theta\u0026#34;), gorgonia.WithShape(xT.Shape()[1]), gorgonia.WithInit(gorgonia.Uniform(0, 1))) pred := must(gorgonia.Mul(x, theta)) // Saving the value for later use  var predicted gorgonia.Value gorgonia.Read(pred, \u0026amp;predicted) Gorgonia est très optimisé; il fait utilise beaucoup les pointeurs pour optimiser son empreinte mémoire. Par conséquemt, appeler la méthode Value() d\u0026rsquo;un *Node pendant la phase d\u0026rsquo;exécution du graphe, peut produire des résultats incorrects. Pour accéder à la valeur contenue dans un *Node (pendant la phase d\u0026rsquo;apprentissage par exemple), il est nécessaire de garder une référence pointant sur ladite valeur. C\u0026rsquo;est la raison pour laquelle nous utilisons la méthode Read. predicted contient une référence à la valeur résultante de l\u0026rsquo;opération $X\\cdot\\Theta$.\n Préparation du calcul du gradient Nous allons utiliser la fonctionnalité de Gorgonia: Symbolic differentiation.\nTout d\u0026rsquo;abord, nous allons créer une fonction de coût, puis utiliser un solver pour faire la descente de gradient.\nCreation du \u0026ldquo;node\u0026rdquo; qui contiendra le coût de l\u0026rsquo;équation Completons à présent l\u0026rsquo;exprgraph en ajoutant le coût (pour rappel, $cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$)\nsquaredError := must(gorgonia.Square(must(gorgonia.Sub(pred, y)))) cost := must(gorgonia.Mean(squaredError)) Notre but est de minimiser ce coût. Nous allons donc calculer le gradient de la fonction par rapport à $\\Theta$:\nif _, err := gorgonia.Grad(cost, theta); err != nil { log.Fatalf(\u0026#34;Failed to backpropagate: %v\u0026#34;, err) } La descente du gradient Nous utilisons le principe de descente de gradient. Ceci signifie que nous utilisons le gradient de la fonction pour altérer le paramètre $\\Theta$ pas à pas.\nUne implémentation basique de descente de gradient est implémentée dans le Vanilla Solver de Gorgonia. Nous positionnons le \u0026ldquo;pas\u0026rdquo; $\\gamma$ à 0.001.\nsolver := gorgonia.NewVanillaSolver(gorgonia.WithLearnRate(0.001)) À chaque étape, nous allons demander au solver de mettre à jour $\\Theta$ grâce au gradient. Par conséquent, nous assignons une variable update que nous allons passer au solver à chaque itération.\nLa descente de gradient va mettre à jour toutes les valeurs présentes dans le tableau []gorgonia.ValueGrad à chqaue étape suivant cette équation: ${\\displaystyle x^{(k+1)}=x^{(k)}-\\gamma \\nabla f\\left(x^{(k)}\\right)}$ Il est important de comprendre que le solver travaille sur des Values et non des Nodes. Cependant, afin de simplifier les choses, l\u0026rsquo;interface ValueGrad est implémenté par la structure *Node.\n Dans notre cas, nous voulons trouver les valeurs de $\\Theta$; nous demandons au solver de mettre à jour la valeur en suivant cette équation:\n${\\displaystyle \\Theta^{(k+1)}=\\Theta^{(k)}-\\gamma \\nabla f\\left(\\Theta^{(k)}\\right)}$\nLe solver se charge d\u0026rsquo;implémenter l\u0026rsquo;équation. Nous devons simplement passer $\\Theta$ a chaque Step du Solver:\nupdate := []gorgonia.ValueGrad{theta} // ... if err = solver.Step(update); err != nil { log.Fatal(err) } L\u0026rsquo;apprentissage À présent que la mécanique est en place, nous devons lancer le calcul grâce à une vm. Ce calcul doit être lancé un grand nombre de fois pour que la descente de gradient puisse agir.\nCréons à présent une vm pour lancer le calcul.\nmachine := gorgonia.NewTapeMachine(g, gorgonia.BindDualValues(theta)) defer machine.Close() Nous demandons au \u0026ldquo;solver\u0026rdquo; de mettre à jour le paramètre $\\Theta$ par rapport au gradient. Par conséquent nous devons dire à la TapeMachine de stocker la valeur de $\\Theta$ ainsi que sa dérivée (sa \u0026ldquo;dual value\u0026rdquo;) Ceci est la raison de l\u0026rsquo;utilisation de la fonction BindDualValues.\n Maintenant nous pouvons créer une boucle et calculer le graphe étape par étape; la machine va apprendre!\niter := 1000000 var err error for i := 0; i \u0026lt; iter; i++ { if err = machine.RunAll(); err != nil { fmt.Printf(\u0026#34;Error during iteration: %v: %v\\n\u0026#34;, i, err) break } if err = solver.Step(model); err != nil { log.Fatal(err) } machine.Reset() // Reset is necessary in a loop like this } Afficher des informations Nous pouvons afficher des informations sur le processus d\u0026rsquo;apprentissage en utilisant cet appel:\nfmt.Printf(\u0026#34;theta: %2.2f Iter: %v Cost: %2.3f Accuracy: %2.2f \\r\u0026#34;, theta.Value(), i, cost.Value(), accuracy(predicted.Data().([]float64), y.Value().Data().([]float64))) Avec la fonction accuracy définie de la manière suivante:\nfunc accuracy(prediction, y []float64) float64 { var ok float64 for i := 0; i \u0026lt; len(prediction); i++ { if math.Round(prediction[i]-y[i]) == 0 { ok += 1.0 } } return ok / float64(len(y)) } Ceci affichera une ligne semblable à celle ci pendant la phase d\u0026rsquo;apprentissage:\ntheta: [ 0.26 -0.41 0.44 -0.62 0.83] Iter: 26075 Cost: 0.339 Accuracy: 0.61 Sauvegarde des données Une fois l\u0026rsquo;entraînement terminé, nous pouvons sauvegarder les valeurs de $\\Theta$ pour pouvoir les utiliser dans des prédictions:\nfunc save(value gorgonia.Value) error { f, err := os.Create(\u0026#34;theta.bin\u0026#34;) if err != nil { return err } defer f.Close() enc := gob.NewEncoder(f) err = enc.Encode(value) if err != nil { return err } return nil } Création d\u0026rsquo;un utilitaire en ligne de commande (CLI) Nous allons à présent créer un utilitaire qui va permettre de donner l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction des paramètres d\u0026rsquo;entrée.\nTout d\u0026rsquo;abord, chargeons les paramètres que nous venons de sauvegarder lors de la phase d\u0026rsquo;entrainement.\nfunc main() { f, err := os.Open(\u0026#34;theta.bin\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() dec := gob.NewDecoder(f) var thetaT *tensor.Dense err = dec.Decode(\u0026amp;thetaT) if err != nil { log.Fatal(err) } Ensuite, créeons le modèle (l\u0026rsquo;exprgraph) d\u0026rsquo;une manière semblable à ce que nous avons fait auparavant:\nDans un développement logiciel, il serait probablement souhaitable de partager ce code entre les deux outils (training et execution) en l\u0026rsquo;isolant dans un package.\n g := gorgonia.NewGraph() theta := gorgonia.NodeFromAny(g, thetaT, gorgonia.WithName(\u0026#34;theta\u0026#34;)) values := make([]float64, 5) xT := tensor.New(tensor.WithBacking(values)) x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y, err := gorgonia.Mul(x, theta) Ensuite nous executons une boucle infinie pendant laquelle nous allons demander les infos, calculer et afficher le résultat:\nmachine := gorgonia.NewTapeMachine(g) values[4] = 1.0 for { values[0] = getInput(\u0026#34;sepal length\u0026#34;) values[1] = getInput(\u0026#34;sepal widt\u0026#34;) values[2] = getInput(\u0026#34;petal length\u0026#34;) values[3] = getInput(\u0026#34;petal width\u0026#34;) if err = machine.RunAll(); err != nil { log.Fatal(err) } switch math.Round(y.Value().Data().(float64)) { case 1: fmt.Println(\u0026#34;It is probably a setosa\u0026#34;) case 2: fmt.Println(\u0026#34;It is probably a virginica\u0026#34;) case 3: fmt.Println(\u0026#34;It is probably a versicolor\u0026#34;) default: fmt.Println(\u0026#34;unknown iris\u0026#34;) } machine.Reset() } Voici une fonction utilitaire pour récupérer les entrées:\nfunc getInput(s string) float64 { reader := bufio.NewReader(os.Stdin) fmt.Printf(\u0026#34;%v: \u0026#34;, s) text, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) text = strings.Replace(text, \u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;, -1) input, err := strconv.ParseFloat(text, 64) if err != nil { log.Fatal(err) } return input } Il ne reste plus qu\u0026rsquo;à \u0026ldquo;builder\u0026rdquo; le code et voilà! Nous avons un utilitaire autonome capable de prédire l\u0026rsquo;espèce d\u0026rsquo;une Irir en fonction de ses attributs:\n$ go run main.go sepal length: 4.4 sepal widt: 2.9 petal length: 1.4 petal width: 0.2 It is probably a setosa sepal length: 5.9 sepal widt: 3.0 petal length: 5.1 petal width: 1.8 It is probably a virginica Conclusion Dans cet exemple pas-à-pas, nous avons construit un logiciel complet.\nÀ présent vous pouvez poursuivre les tests en changeant les valeurs initiales de $\\Theta$ ou en utilisant un autre solver fournit par Gorgonia.\nLe code complet de ce tutoriel est présent dans le répertoire examples des sources de Gorgonia.\nBonus: representation visuelle Il est possible de visualiser le dataset en utilisant la bibliothèque plotter du projet Gonum. Voici un exemple.\nimport ( \u0026#34;gonum.org/v1/plot\u0026#34; \u0026#34;gonum.org/v1/plot/plotter\u0026#34; \u0026#34;gonum.org/v1/plot/plotutil\u0026#34; \u0026#34;gonum.org/v1/plot/vg\u0026#34; \u0026#34;gonum.org/v1/plot/vg/draw\u0026#34; ) func plotData(x []float64, a []float64) []byte { p, err := plot.New() if err != nil { log.Fatal(err) } p.Title.Text = \u0026#34;sepal length \u0026amp; width\u0026#34; p.X.Label.Text = \u0026#34;length\u0026#34; p.Y.Label.Text = \u0026#34;width\u0026#34; p.Add(plotter.NewGrid()) l := len(x) / len(a) for k := 1; k \u0026lt;= 3; k++ { data0 := make(plotter.XYs, 0) for i := 0; i \u0026lt; len(a); i++ { if k != int(a[i]) { continue } x1 := x[i*l+0] // sepal_length \ty1 := x[i*l+1] // sepal_width \tdata0 = append(data0, plotter.XY{X: x1, Y: y1}) } data, err := plotter.NewScatter(data0) if err != nil { log.Fatal(err) } data.GlyphStyle.Color = plotutil.Color(k - 1) data.Shape = \u0026amp;draw.PyramidGlyph{} p.Add(data) p.Legend.Add(fmt.Sprint(k), data) } w, err := p.WriterTo(4*vg.Inch, 4*vg.Inch, \u0026#34;png\u0026#34;) if err != nil { panic(err) } var b bytes.Buffer writer := bufio.NewWriter(\u0026amp;b) w.WriteTo(writer) ioutil.WriteFile(\u0026#34;out.png\u0026#34;, b.Bytes(), 0644) return b.Bytes() }"},{"uri":"https://gorgonia.org/fr/how-to/dataframe/","title":"Créer un tensor depuis un Dataframe (gota)","tags":[],"description":"","content":" Cet article explique comment créer un tenseur depuis un dataframe en utilisant le package gota.\nLe but est de lire un fichier csv et de créer un objet *tensor.Dense de forme (2,2).\nCreation du dataframe depuis le fichier csv Considerons un ficier csv avec le contenu suivant:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... Ceci est un extrait du Iris flower data set. Une copie du dataset peut être téléchargée ici\n Nous voulons créer un tenseur qui contient toutes les valeurs sauf la colonne \u0026ldquo;species\u0026rdquo;.\nCreation du dataframe avec gota le package dataframe de gota propose une fonction ReadCSV qui prend pour argument un io.Reader.\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) df est un DataFrame qui remferme toutes les données présentes dans le fichier.\ngota utilise la première ligne du fichier csv pour référencer les colonnes dans le dataframe\n Supprimons à présent la colonne species du dataframe:\nxDF := df.Drop(\u0026#34;species\u0026#34;) Conversion du dataframe vers une matrice Pour simplifier les choses, nous allons convertir le dataframe en une Matrix telle que définie dans le package gonum (cf la godoc de Matrix). Matrix est une interface. Cependant, la structure Dataframe de gota ne remplit pas le contrat d\u0026rsquo;interface Matrix Nous allons donc encapsuler l\u0026rsquo;objet dans une structure de plus haut niveau et nous allons implémenter les fonctions nécessaire au contrat d\u0026rsquo;interface telle que décrit dans la documentation de gota:\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } Creation du tenseur Nous pouvons à présent créer un tenseur *Dense grâce à la fonction tensor.FromMat64 du package tensor en encapsulant le dataframe dans la structure matrix.\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"https://gorgonia.org/fr/how-to/save-weights/","title":"Sauver les matrices de poids","tags":[],"description":"","content":" But Le but de cet article est de décrire la façon de sauvegarder les valeurs des noeuds values et de les restaurer.\nImplementation La meilleure chose à faire de suite est de de sauvegarder la valeur des noeuds correspondants et de les restaurer.\nLes tenseurs remplissent les contrats d\u0026rsquo;interface GobEncode et GobDecode, ce qui représente la meilleure option. On peut aussi sauvegarder le tableau d\u0026rsquo;éléments sous-jascent au tenseur, mais c\u0026rsquo;est un peu plus complexe.\nVoici un simple code à réaliser de cette façon (il n\u0026rsquo;est pas du tout optimisé, n\u0026rsquo;hésitez pas à le modifier):\npackage main import ( \u0026#34;encoding/gob\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; \u0026#34;gorgonia.org/tensor\u0026#34; ) var ( backup = \u0026#34;/tmp/example_gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // Create the graph  x = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // Init variables  xT, yT, err := readFromBackup() if err != nil { log.Println(\u0026#34;cannot read backup, doing init\u0026#34;, err) xT = tensor.NewDense(gorgonia.Float64, []int{2, 2}, tensor.WithBacking([]float64{0, 1, 2, 3})) yT = tensor.NewDense(gorgonia.Float64, []int{2, 2}, tensor.WithBacking([]float64{0, 1, 2, 3})) } err = gorgonia.Let(x, xT) if err != nil { log.Fatal(err) } err = gorgonia.Let(y, yT) if err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) err = save([]*gorgonia.Node{x, y}) if err != nil { log.Fatal(err) } } func readFromBackup() (tensor.Tensor, tensor.Tensor, error) { f, err := os.Open(backup) if err != nil { return nil, nil, err } defer f.Close() dec := gob.NewDecoder(f) var xT, yT *tensor.Dense log.Println(\u0026#34;decoding xT\u0026#34;) err = dec.Decode(\u0026amp;xT) if err != nil { return nil, nil, err } log.Println(\u0026#34;decoding yT\u0026#34;) err = dec.Decode(\u0026amp;yT) if err != nil { return nil, nil, err } return xT, yT, nil } func save(nodes []*gorgonia.Node) error { f, err := os.Create(backup) if err != nil { return err } defer f.Close() enc := gob.NewEncoder(f) for _, node := range nodes { err := enc.Encode(node.Value()) if err != nil { return err } } return nil } Qui donne:\n$ go run main.go 2019/10/28 08:07:26 cannot read backup, doing init open /tmp/example_gorgonia: no such file or directory ⎡0 2⎤ ⎣4 6⎦ $ go run main.go 2019/10/28 08:07:29 decoding xT 2019/10/28 08:07:29 decoding yT ⎡0 2⎤ ⎣4 6⎦"},{"uri":"https://gorgonia.org/fr/how-to/autodiff/","title":"Comment calculer le gradient (dérivation)","tags":[],"description":"","content":" Objectif Prenez cette équation simple :\n$$ f(x,y,z) = ( x + y ) \\times z $$\nL\u0026rsquo;objectif de cet article est de vous montrer comment Gorgonia peut évaluer le gradient $\\nabla f$ avec ses dérivées partielles :\n$$ \\nabla f = [\\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z}] $$\nExplication En utilisant la règle de dérivation d\u0026rsquo;une fonction composée, on peut obtenir la valeur du gradient à chaque étape comme démontré ici :\ngraph LR; x --|$x=-2$\n$\\partial f/\\partial x = -4$| add y --|$y=5$\n$\\partial f/\\partial y = -4$| add add(+) --|$q=3$\n$\\partial f/\\partial q = -4$| mul z --|$z=-4$\n$\\partial f/\\partial z = 3$| mul mul(*) --|$f=-12$\n$1$| f  Pour plus d\u0026rsquo;informations sur le calcul de gradient, veuillez lire cet article de cs231n (en anglais) de Stanford.\n Nous allons représenter cette équation dans un exprgraph et voir comment demander à Gorgonia de calculer le gradient.\nQuand le calcul est effectué, chaque point aura une double valeur qui contiendra à la fois sa valeur réelle et la dérivée wrt de x.\npar exemple, prenons le point x :\nvar x *gorgonia.Node Une fois que Gorgonia a évalué l\u0026rsquo;exprgraph, il est possible d\u0026rsquo;extraire la valeur de x aet la valeur du gradient $\\frac{\\partial f}{\\partial x}$ en appelant :\nxValue := x.Value() // -2 dfdx, _ := x.Grad() // -4, please check for errors in proper code Voyons comment faire cela.\nCréer l\u0026rsquo;équation D\u0026rsquo;abord, créons l\u0026rsquo;exprgraph qui représente l\u0026rsquo;équation.\nSi vous voulez plus d\u0026rsquo;infos sur cette partie, veuillez lire le tutoriel hello world.\n g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) z = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;z\u0026#34;)) q, err := gorgonia.Add(x, y) if err != nil { log.Fatal(err) } result, err := gorgonia.Mul(z, q) if err != nil { log.Fatal(err) } Et définissez quelques valeurs :\ngorgonia.Let(x, -2.0) gorgonia.Let(y, 5.0) gorgonia.Let(z, -4.0) Obtenir les gradients Il y a deux manières d\u0026rsquo;obtenir les gradients :\n en utilisant la compétence de dérivation automatique de la LispMachine; en utilisant la compétence de calcul symbolique proposée par Gorgonia;  Dérivation automatique La dérivation automatique n\u0026rsquo;est possible qu\u0026rsquo;avec la LispMachine. Par défaut, lispmachine fonctionne avec des mode d\u0026rsquo;exécution en avant et en arrière.\nAinsi, utiliser la méthode RunAll suffit pour obtenir le résultat.\nm := gorgonia.NewLispMachine(g) defer m.Close() if err = m.RunAll(); err != nil { log.fatal(err) } Les valeurs et gradients peuvent à présent être extraites :\nfmt.Printf(\u0026#34;x=%v;y=%v;z=%v\\n\u0026#34;, x.Value(), y.Value(), z.Value()) fmt.Printf(\u0026#34;f(x,y,z) = %v\\n\u0026#34;, result.Value()) if xgrad, err := x.Grad(); err == nil { fmt.Printf(\u0026#34;df/dx: %v\\n\u0026#34;, xgrad) } if ygrad, err := y.Grad(); err == nil { fmt.Printf(\u0026#34;df/dy: %v\\n\u0026#34;, ygrad) } if xgrad, err := z.Grad(); err == nil { fmt.Printf(\u0026#34;df/dx: %v\\n\u0026#34;, xgrad) } Calcul symbolique Une autre option est d\u0026rsquo;utiliser le calcul symbolique. Le calcul symbolique fonctionne en ajoutant des points aux graphiques. Ces nouveaux points contiennent les gradients par rapport aux nœuds passés en argument.\nPour créer ces nouveaux points, on utilise la fonction Grad().\nGrad prend un point de coût scalaire et une liste de ce qui concerne, et renvoie le gradient.\nPrenez le code suivant :\nvar grads Nodes if grads, err = Grad(result,z, x, y); err != nil { log.Fatal(err) } Cela signifie qu\u0026rsquo;il faut calculer les dérivées partielles (gradients) par rapport à z, x et y.\ngrads dans un tableau de []*gorgonia.Node, dans le même ordre que les WRTs qui y sont passés :\n grads[0] = $\\frac{\\partial f}{\\partial z}$ grads[1] = $\\frac{\\partial f}{\\partial x}$ grads[2] = $\\frac{\\partial f}{\\partial y}$  Le gradient est compatible avec TapeMachine et LispMachine. Mais TapeMachine est beaucoup plus rapide.\nmachine := gorgonia.NewTapeMachine(g) defer machine.Close() if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;result: %v\\n\u0026#34;, result.Value()) if zgrad, err := z.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dx: %v | %v\\n\u0026#34;, zgrad, grads[0].Value()) } if xgrad, err := x.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dx: %v | %v\\n\u0026#34;, xgrad, grads[1].Value()) } if ygrad, err := y.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dy: %v | %v\\n\u0026#34;, ygrad, grads[2].Value()) } Notez que vous pouvez accéder aux dérivées partielles de deux manières :\n En utlisant la méthode .Grad() par exemple pour le gradient de x dans l\u0026rsquo;exemple présent, utilisez x.Grad() En utlisant la méthode .Value() du point gradient par exemple pour le gradient de x de l\u0026rsquo;exemple, utilisez grads[1].Value().  La raison d\u0026rsquo;avoir ces deux manières différentes de faire les choses se résume à la pertinence. Lorsqu\u0026rsquo;il est plus significatif d\u0026rsquo;obtenir des valeurs à partir des points de gradient (par exemple, vous pouvez vouloir calculer la dérivée seconde), utilisez les nœuds de gradient. Mais si vous voulez une récupération rapide des valeurs de gradient, la méthode .Grad() pourrait être la plus appropriée. En fin de compte, cela dépend de votre goût.\nFull Code (Dérivation automatique) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) z = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;z\u0026#34;)) q, err := gorgonia.Add(x, y) if err != nil { log.Fatal(err) } result, err := gorgonia.Mul(z, q) if err != nil { log.Fatal(err) } // set initial values then run  gorgonia.Let(x, -2.0) gorgonia.Let(y, 5.0) gorgonia.Let(z, -4.0) // by default, lispmachine performs forward mode and backwards mode execution  m := gorgonia.NewLispMachine(g) defer m.Close() if err = m.RunAll(); err != nil { log.fatal(err) } fmt.Printf(\u0026#34;x=%v;y=%v;z=%v\\n\u0026#34;, x.Value(), y.Value(), z.Value()) fmt.Printf(\u0026#34;f(x,y,z)=(x+y)*z\\n\u0026#34;) fmt.Printf(\u0026#34;f(x,y,z) = %v\\n\u0026#34;, result.Value()) if xgrad, err := x.Grad(); err == nil { fmt.Printf(\u0026#34;df/dx: %v\\n\u0026#34;, xgrad) } if ygrad, err := y.Grad(); err == nil { fmt.Printf(\u0026#34;df/dy: %v\\n\u0026#34;, ygrad) } if xgrad, err := z.Grad(); err == nil { fmt.Printf(\u0026#34;df/dz: %v\\n\u0026#34;, xgrad) } } qui donne :\n$ go run main.go x=-2;y=5;z=-4 f(x,y,z)=(x+y)*z f(x,y,z) = -12 df/dx: -4 df/dy: -4 df/dz: 3 Full Code (Calcul symbolique) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) z = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;z\u0026#34;)) q, err := gorgonia.Add(x, y) if err != nil { log.Fatal(err) } result, err := gorgonia.Mul(z, q) if err != nil { log.Fatal(err) } if grads, err = Grad(result,z, x, y); err != nil { log.Fatal(err) } // set initial values then run  gorgonia.Let(x, -2.0) gorgonia.Let(y, 5.0) gorgonia.Let(z, -4.0) machine := gorgonia.NewTapeMachine(g) defer machine.Close() if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;x=%v;y=%v;z=%v\\n\u0026#34;, x.Value(), y.Value(), z.Value()) fmt.Printf(\u0026#34;f(x,y,z)=(x+y)*z\\n\u0026#34;) fmt.Printf(\u0026#34;f(x,y,z) = %v\\n\u0026#34;, result.Value()) if zgrad, err := z.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dx: %v | %v\\n\u0026#34;, zgrad, grads[0].Value()) } if xgrad, err := x.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dx: %v | %v\\n\u0026#34;, xgrad, grads[1].Value()) } if ygrad, err := y.Grad(); err == nil { fmt.Printf(\u0026#34;dz/dy: %v | %v\\n\u0026#34;, ygrad, grads[2].Value()) } } qui donne :\n$ go run main.go x=-2;y=5;z=-4 f(x,y,z)=(x+y)*z f(x,y,z) = -12 df/dx: -4 | -4 df/dy: -4 | -4 df/dz: 3 | 3"},{"uri":"https://gorgonia.org/fr/reference/vm/gomachine/","title":"Go Machine","tags":[],"description":"Cette page explique la tuyauterie à l&#39;intérieur de la Go Machine","content":" Cette page explique la tuyauterie à l\u0026rsquo;intérieur de la Go Machine.\nGoMachine est une fonctionnalité expérimentale contenue dans le package xvm. L\u0026rsquo;API du package et son nom pourraient changer. Ce document s\u0026rsquo;appuie sur le commit 7538ab3\nLes états des noeuds Le principe repose sur les états des noeuds.\nComme expliqué dans la vidéo Lexical Scanning in Go:\n un état représente où nous sommes une action représente ce que nous faisons les actions activent un nouvel état  A ce jour, la GoMachine attend d\u0026rsquo;un noeud d\u0026rsquo;être dans ces divers états:\n waiting for input emitting output  Si un noeud contient un opérateur, il peut y avoir un nouvel état:\n computing   Ultérieurement, un nouvel état va être ajouté quand la différenciation automatique sera implémentée\n Ceci amène à ce graphique des différents états d\u0026rsquo;un noeud:\ngraph TB; A(Initial Stage) -- BB{input is an op} BB --|no| D[Emit output] BB --|yes| B[Waiting for input] B -- C{inputs == arity} C --|no| B C --|yes| Computing Computing -- E{Has error} E --|no| D E --|yes| F D -- F(end)  Implémentation Le noeud (node) est une structure privée:\ntype node struct { // ... } On définit un type stateFn qui représente une action pour éxécuter un noeud (*node) dans un contexte spécifique (context) et entraine un nouvel état. L\u0026rsquo;objet stateFn est de typefunc:\ntype stateFn func(context.Context, *node) stateFn Note: C\u0026rsquo;est la responsabilité de chaque fonction d\u0026rsquo;état de maintenir le mécanisme d\u0026rsquo;annulation du contexte. Cela signifie que si un signal d\u0026rsquo;annulation est reçu, le noeud devrait renvoyer à l\u0026rsquo;état final. pour faire simple:\nfunc mystate(ctx context.Context, *node) stateFn { // ...  select { // ...  case \u0026lt;- ctx.Done(): n.err = ctx.Error() return nil } } on définit 4 fonctions de type stateFn qui vont implémenter les actions requises par les opérations portées par les noeuds:\nfunc defaultState(context.Context, *node) stateFn { ... } func receiveInput(context.Context, *node) stateFn { ... } func computeFwd(context.Context, *node) stateFn { ... } func emitOutput(context.Context, *node) stateFn { ... } Note: Le statut final est nil (la valeur nulle de stateFn)\nExécuter la machine d\u0026rsquo;état Chaque noeud est une machine d\u0026rsquo;état. Pour l\u0026rsquo;éxécuter, on fixe une méthode run qui utilise le contexte comme argument.\nfunc (n *node) Compute(ctx context.Context) error { for state := defaultState; state != nil; { state = state(ctx, n) } return n.err } Note: le noeud (*node) stocke une erreur qui devrait être écrite par une stateFn. Cette fonction d\u0026rsquo;état indique la raison pour laquelle la machine d\u0026rsquo;état a été cassée (par exemple, si une erreur survient durant le calcul, cette erreur contient la raison.)\nPuis chaque noeud (*node) est déclenché dans sa propre Goroutine par la machine.\nModification d\u0026rsquo;état dans un événement On utilise le paradigme de la programmation réactive pour passer d\u0026rsquo;un état à un autre.\nUn changement dans la stucture du noeud (*node) déclenche une action qui va induire un changement d\u0026rsquo;état.\nPar exemple, prenons un simple calculateur qui calcule a+b.\n $+$ attend 2 valeurs d\u0026rsquo;entrée pour faire la somme de $a$ et $b$ $a$ attend une valeur $b$ attend une valeur  Quand on envoie une valeur à $a$, $+$ est notifié de l\u0026rsquo;événement ($a$ possède sa propre valeur); il reçoit et stocke en interne la valeur\nQuand on envoie une valeur $b$, $+$ est informé, et reçoit la valeur. Son état change alors en compute.\nUne fois compilé, le $+$ envoie le résultat à quiconque est intéressé par son usage.\nEn Go, envoyer et recevoir des valeurs, et programmer des événements nécessitent d\u0026rsquo;être implémentés avec des canaux (channels).\nLa structure du noyeau possède 2 canaux, un pour recevoir les entrées (inputC), et un pour émettre les sorties (outputC):\ntype node struct { outputC chan gorgonia.Value inputC chan ioValue err error // ... } Note: La structure ioValue est expliquée plus loin dans ce document; pour le moment, considérons que ioValue = gorgonia.Value\nHUB de communication Désormais, tous les noeuds tournent dans des goroutines; on doit les cabler entre elles pour calculer une formule.\nPar exemple, dans: $ a\\times x+b$, on doit envoyer le résultat de $a\\times x$ au noeud qui porte l\u0026rsquo;opération addition.\nce qui donne à peu près:\nvar aTimesX *node{op: mul} var aTimesXPlusB *node{op: sum} var a,b,c gorgonia.Value aTimesX.inputC \u0026lt;- a aTimesX.inputC \u0026lt;- x aTimesXPlusB.inputC \u0026lt;- \u0026lt;- aTimesX.outputC aTimesXPlusB.inputC \u0026lt;- \u0026lt;- b Le problème est que le canal n\u0026rsquo;est pas un \u0026ldquo;topic\u0026rdquo; et il ne gère pas les abonnements de manière native. Le premier consommateur prend une valeur, et vide le canal.\nDonc si on prend l\u0026rsquo;équation $(a + b) \\times c + (a + b) \\times d$, l\u0026rsquo;implémentation ne devrait pas fonctionner:\n1 2 3 4 5 6 7 8 9 10 11 12  var aPlusB *node{op: add} var aPlusBTimesC *node{op: mul} var aPlusBTimesCPlusAPlusB *node{op: add} var a,b,c gorgonia.Value aPlusB.inputC \u0026lt;- a aPlusB.inputC \u0026lt;- b aPlusBTimesC.inputC \u0026lt;- \u0026lt;- aPlusB.outputC aPlusBTimesC.inputC \u0026lt;- c aPlusBTimesCPlusAPlusB \u0026lt;- \u0026lt;- aPlusBTimesC.outputC aPlusBTimesCPlusAPlusB \u0026lt;- \u0026lt;- aPlusB.outputC // Deadlock   Ceci devrait provoquer une impasse car aPlusB.outputC est vide à la ligne 9 et donc la ligne 12 ne recevra plus jamais de valeur.\nLa solution est d\u0026rsquo;utiliser des canaux temporaires et un mécanisme diffusé comme décrit dans l\u0026rsquo;article Go Concurrency Patterns: Pipelines and cancellation.\nPublier / souscrire Un noeud publie du contenu pour des abonnés. Le noeud inscrit aussi du contenu pour des producteurs.\nOn associe 2 structures:\ntype publisher struct { id int64 publisher \u0026lt;-chan gorgonia.Value subscribers []chan\u0026lt;- gorgonia.Value } type subscriber struct { id int64 publishers []\u0026lt;-chan gorgonia.Value subscriber chan\u0026lt;- ioValue } Chaque noeud qui fournit une sortie via outputC est un producteur, et tous les noeuds du graphique qui rejoignent ce premier noeud sont ses abonnés. Ceci définit un objet producteur. L\u0026rsquo;identifiant de l\u0026rsquo;objet est l\u0026rsquo;identifiant du noeud qui envoie sa sortie (output).\nChaque noeud qui attend une entrée via soninputC est un abonné. Les producteurs sont les noeuds atteints par ce premier noeud dans le *ExprGraph\nFusionner et diffuser Les producteurs diffusent leurs données à l\u0026rsquo;abonné en appelant la fonction broadcast.\nfunc broadcast(ctx context.Context, globalWG *sync.WaitGroup, ch \u0026lt;-chan gorgonia.Value, cs ...chan\u0026lt;- gorgonia.Value) { ... }  Les abonnés fusionnent les résultats issus des producteurs par appel à la fonction merge\nfunc merge(ctx context.Context, globalWG *sync.WaitGroup, out chan\u0026lt;- ioValue, cs ...\u0026lt;-chan gorgonia.Value) { ... } Note:les 2 fonctions gèrent l\u0026rsquo;annulation du contexte\npubsub Pour cabler les producteurs et les abonnés, on utilise la structure de plus haut niveau: pubsub\ntype pubsub struct { publishers []*publisher subscribers []*subscriber } pubsub est chargé de mettre en place le réseau de canaux.\nUne méthode run(context.Context) déclenche la diffusion ( broadcast) et fusion (merge) de tous les éléments:\nfunc (p *pubsub) run(ctx context.Context) (context.CancelFunc, *sync.WaitGroup) { ... } Cett méthode retourne un context.CancelFunc et un sync.WaitGroup qui vont tomber à 0 quand tous les pubsubs sont colonisés après une annulation.\nA propos de ioValue L\u0026rsquo;abonné a un seul canal d\u0026rsquo;entrée; la valeur de sortie peut être envoyée dans n\u0026rsquo;importe quel ordre. La fonction merge de l\u0026rsquo;abonné traque l\u0026rsquo;ordre des abonnés, inclut la valeur dans la structure ioValue, et ajoute la position de l\u0026rsquo;opérateur qui a émis cette valeur:\ntype ioValue struct { pos int v gorgonia.Value } La machine La Machine est la seule structure exportée du package.\nC\u0026rsquo;est un support pour les noeuds et pubsub.\ntype Machine struct { nodes []*node pubsub *pubsub } Création de la machine Une machine est créée à partir de *ExprGraph en appelant la fonction:\nfunc NewMachine(g *gorgonia.ExprGraph) *Machine { ... } De manière sous-jascente, il analyse le graphique et génère un noeud (*node) pour chaque noeud gorgonia (*gorgonia.Node). Si un noeud porte une opération Op (= un objet qui implémente une méthode Do(... Value) Value ), un pointeur sur l\u0026rsquo;opération est ajouté à la structure.\nPour faire la transition, le package déclare une interface Doer. Cette interface est validée par la strucure *gorgonia.Node.\n Deux cas particuliers sont pris en charge:\n Le noeud de plus haut niveau du graphe *ExprGraph contientoutputC = nil les derniers noeuds du *ExprGraph présentent inputC = nil  puis la nouvelle machine(NewMachine) fait appel aux méthodes de création de réseau pour créer les éléments *pubsub.\nExécuter la machine Un appel à la méthodeRun de la machine déclenche le calcul. L\u0026rsquo;appel à cette fonction est bloqué. Il renvoie une erreur et stoppe le process si:\n tous les noeuds ont atteint leur état final ou l\u0026rsquo;état d\u0026rsquo;éxécution d\u0026rsquo;un noeud renvoie une erreur  En cas d\u0026rsquo;erreur, un signal d\u0026rsquo;annulation est automatiquement envoyé à l\u0026rsquo;infrastructure *pubsub pour éviter les fuites mémoire.\nFermer la machine Après le calcul, il est sécuritaire d\u0026rsquo;appeler Close pour éviter une fuite mémoire. Close() ferme tous les canaux tenus par le noeud *node et le *pubsub\nDivers Il est important de remarquer que la machine est indépendante du *ExprGraph. Donc les valeurs contenues par le *gorgonia.Node ne sont pas mises à jour.\nPour accéder aux données, on doit appeler la méthode GetResult de la machine. cette méthode utilise l\u0026rsquo;identifiant d\u0026rsquo;un noeud comme entrée ( le noeud (*node) et noeud gorgonia ( *gorgonia.Node) ont les mêmes identifiants)\nEx:\nvar add, err := gorgonia.Add(a,b) fmt.Println(machine.GetResult(add.ID())) Exemple Voici un exemple trivial qui effectue un calcul sur des float32\nfunc main(){ g := gorgonia.NewGraph() forty := gorgonia.F32(40.0) two := gorgonia.F32(2.0) n1 := gorgonia.NewScalar(g, gorgonia.Float32, gorgonia.WithValue(\u0026amp;forty), gorgonia.WithName(\u0026#34;n1\u0026#34;)) n2 := gorgonia.NewScalar(g, gorgonia.Float32, gorgonia.WithValue(\u0026amp;two), gorgonia.WithName(\u0026#34;n2\u0026#34;)) added, err := gorgonia.Add(n1, n2) if err != nil { log.Fatal(err) } machine := NewMachine(g) ctx, cancel := context.WithTimeout(context.Background(), 1000*time.Millisecond) defer cancel() defer machine.Close() err = machine.Run(ctx) if err != nil { log.Fatal(err) } fmt.Println(machine.GetResult(added.ID())) } affiche\n42"},{"uri":"https://gorgonia.org/fr/reference/","title":"References","tags":[],"description":"","content":""},{"uri":"https://gorgonia.org/fr/","title":"Gorgonia","tags":[],"description":"","content":" Gorgonia Gorgonia est une bibliothèque qui facilite la mise en place de mécanismes de machine learning en Go.\nElle permet d\u0026rsquo;écrire et de calculer des équations mathématiques utilisant des tableaux à multiples dimensions.\nDans l\u0026rsquo;idée, cette bibliothèque est semblable à Theano et TensorFlow.\nD\u0026rsquo;une manière générale, cette bibliothèque est relativement bas-niveau, comme Theano, mais possède des objectifs plus ambitieux comme TensorFlow.\nPourquoi utiliser Gorgonia ? La cible principale de Gorgonia est de rendre l\u0026rsquo;expérience du développeur agréable. So vous êtes un Gopher, grâce à Gorgonia, vous avez la possibilité de créer des systèmes utilisant le machine learning qui soient \u0026ldquo;production-ready\u0026rdquo;.\nLe développement en IA/ML est généralement divisé en deux étapes:\n Les expériences pendant lesquels sont conçus les modèles, et pendant lesquels beaucoup de tests sont réalisés. La phase de déploiement pendant laquelle les modèles sont industrialisés pour être opérés à l\u0026rsquo;échelle.  Ces différentes phases sont associées à divers métiers tels que data-scientiste ou data-ingénieur.\nD\u0026rsquo;une manière générale, ces deux étapes ne sont pas réalisées en utilisant les mêmes outils:\n Python/Lua (et les frameworks de type Theano, Torch, etc), sont couramment utilisés dans les phases d\u0026rsquo;expérimentation. Durant les phases d\u0026rsquo;exploitation et de déploiement, le modèle est en général réécrit dans un langage plus performant tel que le C++. (en utilisant par exemple dlib, mlpack etc).  Bien entendu, de nos jours, l\u0026rsquo;écart de performance entre les outils se réduit, ce qui aboutit à un partage des outils entre les différentes phases. TensorFlow est un exemple d\u0026rsquo;outil qui est utilisé dans les deux étapes du développement et qui opère comme un pont entre deux.\nLe but de Gorgonia est le même, mais dans l\u0026rsquo;écosystème Go. Gorgonia est performant. Sa vitesse d\u0026rsquo;exécution sur CPU est comparable à Theano et TensorFlow. Les implémentations GPU sont plus délicates à comparer dû à la charge induite par l\u0026rsquo;utilisation de CGO. Cette partie est en développement actif.\nOrganisation de ce site web Ce site web est composé de 4 sections ayant différents objectifs:\n Premiers pas  Démarrer rapidement avec Gorgonia\n Fonctionnement de Gorgonia  Suite d\u0026#39;articles pour expliquer le fonctionnement de Gorgonia\n Tutoriels  Tutoriels sur quelques cas d\u0026#39;usage\n Guide pratique  Plusieurs guides pratiques pour résoudre un problème précis avec Gorgonia\n References  \n "},{"uri":"https://gorgonia.org/fr/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://gorgonia.org/fr/tags/","title":"Tags","tags":[],"description":"","content":""}]