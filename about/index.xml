<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>How Gorgonia works on Gorgonia</title><link>https://gorgonia.org/about/</link><description>Recent content in How Gorgonia works on Gorgonia</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 28 Oct 2019 11:41:02 +0100</lastBuildDate><atom:link href="https://gorgonia.org/about/index.xml" rel="self" type="application/rss+xml"/><item><title>Computation Graph</title><link>https://gorgonia.org/about/computation-graph/</link><pubDate>Sun, 10 Nov 2019 21:09:19 +0100</pubDate><guid>https://gorgonia.org/about/computation-graph/</guid><description>Gorgonia is Graph based Note: this article takes its inspiration from this blog post
Like most deep learning libraries such as Tensorflow or Theano, Gorgonia relies on the concept that equations are representable by graphs.
It exposes the equation graph as an ExprGraph object that can be manipulated by the programmer.
So instead of writing:
func main() { fmt.Printf(&amp;#34;%v&amp;#34;, 1+1) } the programmer should write:
func main() { // Create a graph.</description></item></channel></rss>