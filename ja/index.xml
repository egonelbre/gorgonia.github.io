<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>main on Gorgonia</title><link>https://gorgonia.org/ja/</link><description>Recent content in main on Gorgonia</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 29 Oct 2019 14:59:59 +0100</lastBuildDate><atom:link href="https://gorgonia.org/ja/index.xml" rel="self" type="application/rss+xml"/><item><title>計算グラフ</title><link>https://gorgonia.org/ja/about/computation-graph/</link><pubDate>Sun, 10 Nov 2019 21:09:19 +0100</pubDate><guid>https://gorgonia.org/ja/about/computation-graph/</guid><description>Gorgonia はグラフベース _Note_：この記事は このブログ投稿 からインスピレーションを得ています。
Tensorflow や Theano など殆どの深層学習ライブラリと同様に、Gorgonia は方程式がグラフで表現できるという概念に依存しています。
方程式グラフをプログラマーが操作できる ExprGraph オブジェクトとして公開します。
ですので以下の様に書く代わりに:
func main() { fmt.Printf(&amp;#34;%v&amp;#34;, 1+1) } プログラマはこう書くのです:
func main() { // Create a graph. g := gorgonia.NewGraph() // Create a node called &amp;#34;x&amp;#34; with the value 1. x := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;x&amp;#34;)) // Create a node called &amp;#34;y&amp;#34; with the value 1. y := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;y&amp;#34;)) // z := x + y z := gorgonia.</description></item><item><title>グラフと Exprgraph</title><link>https://gorgonia.org/ja/reference/exprgraph/</link><pubDate>Tue, 29 Oct 2019 19:49:05 +0100</pubDate><guid>https://gorgonia.org/ja/reference/exprgraph/</guid><description>計算グラフまたは式グラフについて多くのことが言われています。しかしそれらは正しいのでしょうか？あなたが望む数学表現の AST と考えてください。上記の例のグラフを次に示します(ただし代わりにベクトルとスカラーを追加します):
ちなみに Gorgonia には素敵なグラフ印刷機能が備わっています。方程式 $y = x^2$ とその派生のグラフの例を次に示します:
グラフを読むのは簡単です。式は下から上に構築され、派生は上から下に構築されます。これにより各ノードの導関数はほぼ同じレベルとなります。
赤枠のノードはそれがルート node であることを示します。緑のアウトラインノードは葉 node であることを示します。背景が黄色のノードは入力ノードであることを示しています。点線の矢印はどのノードがポイント先ノードのグラデーションノードであるかを示しています。
具体的には c42011e840 ($\frac{\partial{y}}{\partial{x}}$) が入力 c42011e000 (つまり $x$) の勾配ノードであると言います。</description></item><item><title>こんにちわ世界</title><link>https://gorgonia.org/ja/tutorials/hello-world/</link><pubDate>Tue, 29 Oct 2019 17:54:31 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/hello-world/</guid><description>これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。
私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:
$ f(x,y) = x + y $
値は x = 2 と y = 5
どの様に動作するか x + y = z の評価はグラフで表す事ができます:
graph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y 結果を計算する為に4つのステップを使います:
Gorgonia で式の様なグラフを作成する nodes x と y に幾つかの値を設定する gorgonia vm上でグラフを起動する node zからvalueを取り出す * グラフの作成 以下の方法で空の式グラフを作成します:
g := gorgonia.NewGraph() ノードの作成 いくつかのノードを作成しそれらを ExprGraph に関連付けます。
var x, y, z *gorgonia.Node プレースホルダの作成 xとyはスカラー変数です。対応するノードは次のように作成できます:
x = gorgonia.</description></item><item><title>簡単なニューラルネットの構築 (MNIST)</title><link>https://gorgonia.org/ja/tutorials/mnist/</link><pubDate>Tue, 29 Oct 2019 20:09:05 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/mnist/</guid><description>はじめに これは MNIST データセットを使って convocation neural network を段階的に構築し練習する為のチュートリアルです。
完全なコードは、Gorgonia メインリポジトリの examples ディレクトリにあります。 このチュートリアルの目的はコードを詳細に説明することです。 仕組みの詳細については、次の書籍で見ることができます。 Go Machine Learning Projects
データセット このパートではデータセットの読み込みと表示について説明します。ニューラルネットの個所に直接ジャンプしたい場合はスキップして Convolution Neural Net part に進んでください。
学習およびテストセットは次からダウンロードできます。 Yann LeCun&amp;rsquo;s MNIST website
train-images-idx3-ubyte.gz: training set images (9912422 bytes) train-labels-idx1-ubyte.gz: training set labels (28881 bytes) t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes) Every image/label starts with a magic number. The encoding/binary package of the standard library of Go makes it easy to read those files.</description></item><item><title>発表</title><link>https://gorgonia.org/ja/reference/present/</link><pubDate>Mon, 04 Nov 2019 09:38:27 +0100</pubDate><guid>https://gorgonia.org/ja/reference/present/</guid><description> このページにはプレゼンテーション内で使用できる資料が含まれています。
ロゴ Logos logo_g.svg (22 ko) logo_g_square.png (142 ko) logo_horizontal.svg (25 ko) logo_vertical.svg (25 ko)</description></item><item><title>普遍的な用語集</title><link>https://gorgonia.org/ja/getting-started/ubiquitous-language/</link><pubDate>Fri, 26 Nov 2021 22:45:36 +0100</pubDate><guid>https://gorgonia.org/ja/getting-started/ubiquitous-language/</guid><description> このページは、Gorgonia を理解し、（PR やイシュー報告を通じて）開発チームに連絡するときの助けとなる言葉の定義や用語集です。
テンソル inner(most) dimension(s), インナーディメンジョン - 次元、行数、列数（shape）が与えられるとき、内側の次元は右側にあります。例えば、shape (2,3,4) の場合、インナーディメンジョンは、(3, 4) （3 行、4 列）であり、インナーモストディメンジョンは、4 です。 outer(most) dimension(s), アウターディメンジョン - 次元、行数、列数（shape）が与えられるとき、外側の次元は左側にあります。例えば、shape (2,3,4) の場合、アウターディメンジョンは、(2, 3) （2 次元, 3 行）であり、アウターモストディメンジョンは、2 です。 vector, ベクトル - 階数 1 の tensor です。例えば、(2), (3) など&amp;hellip; ベクトルは、[...] のように記述されます。 column vector （あるいは、colvec）, 縦ベクトル - 内側の次元が 1 かつ階数 2 の tensor （例えば、行列）です。例えば、(2, 1), (3, 1)&amp;hellip; row vector, 行ベクトル - 外側の次元が 1 かつ階数 2 の tensor（例えば、行列）です。例えば、(1, 2), (1, 3)&amp;hellip; matrix, 行列 - 任意の内側、外側の次元を持ち、かつ階数 2 の tensor です。例えば、(1, 2), (2, 1), (2, 3) など&amp;hellip; このドキュメント内では完全記法で記述されます。列ベクトルや行ベクトルもこの記法に従います。</description></item><item><title>ドキュメントへの貢献を始める</title><link>https://gorgonia.org/ja/getting-started/contributing-doc/</link><pubDate>Fri, 31 Jan 2020 14:59:03 +0100</pubDate><guid>https://gorgonia.org/ja/getting-started/contributing-doc/</guid><description>Gorgonia のドキュメントへの貢献を始めたい場合は、このページとこのページからリンクされたトピックが開始に役立ちます。Gorgonia のドキュメントとユーザ体験に大きな影響を与える様な開発者であったりテクニカルライターである必要はありません。このページのトピックに必要なのは、GitHub アカウントとウェブブラウザだけです。
Gorgonia のコードリポジトリへの貢献を開始する方法についてお探しの場合、貢献ガイドラインを参照してください。
ドキュメントに関する基本事項 Gorgonia のドキュメントは Markdown で記述され、Hugo を使って処理および展開されます。ソースは GitHub の https://github.com/gorgonia/gorgonia.github.io にあります。ほぼ全てのドキュメントソースは /content/ に保存されています。
issue の登録、コンテンツの編集、他のユーザーからの変更のレビュー、その他全てを GitHub のウェブサイトから行えます。GitHub 組み込みの履歴表示や検索ツールを使用することもできます。
ドキュメントのレイアウト ドキュメントは What nobody tells you about documentation の記事で説明されているレイアウトに沿っています。
これは4つのセクションに分かれています。各セクションはリポジトリの content/ ディレクトリのサブディレクトリです。
チュートリアル チュートリアルとは:
学習指向であり 新参の方でも始められ レッスンであること 類似: 小さな子供に料理を教える
リポジトリ内のコンテンツのソース: content/tutorials
ハウツーガイド ハウツーガイドとは:
目標指向であり 特定の問題を解決する方法を示しており 一連の手順であること 類似: 料理本のレシピ
リポジトリ内のコンテンツのソース: content/how-to
説明 説明とは:
理解志向であり 説明しており 背景とコンテキストを提供すること 類似: 料理の社会史に関する記事
リポジトリ内のコンテンツのソース: content/about
リファレンス 情報指向であり 機構について説明しており 正確で完全であること 類似: 参照百科事典の記事</description></item><item><title>Graphviz (dot) を用いた ExprGraph の描画</title><link>https://gorgonia.org/ja/how-to/dot/</link><pubDate>Sun, 01 Dec 2019 10:14:55 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/dot/</guid><description>Gorgonia の encoding パッケージには、ExprGraph を dot language にマーシャリングする関数が含まれています。
これにより graphviz プログラムを用いてグラフの png または svg バージョンを生成することができます。
簡単な方法:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;gorgonia.org/gorgonia&amp;#34; &amp;#34;gorgonia.org/gorgonia/encoding/dot&amp;#34; ) func main() { g := gorgonia.NewGraph() var x, y *gorgonia.Node // define the expression x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(&amp;#34;x&amp;#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(&amp;#34;y&amp;#34;)) gorgonia.Add(x, y) b, err := dot.Marshal(g) if err != nil { log.Fatal(err) } fmt.Println(string(b)) } このプログラムを実行して出力を dot プロセスに送り込むと画像が生成されます。
例:
$ go run main.</description></item><item><title>Iris データセットでの多変量線形回帰</title><link>https://gorgonia.org/ja/tutorials/iris/</link><pubDate>Thu, 31 Oct 2019 14:53:37 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/iris/</guid><description>はじめに Gorgoniaを使用して線形回帰モデルを作成します。
ゴールは以下に与えられた特性を考慮して花の種別を予測することです:
sepal_length sepal_width petal_length petal_width 存在する種別は以下の通り:
setosa virginica versicolor このチュートリアルのゴールはgorgoniaを使用して、与えられたirisデータセットから $\Theta$ の正しい値を見つけ以下のようなcliユーティリティを作成することです:
./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa このチュートリアルは学術目的の為の物です。Gorgoniaでこれをどの様にして行うかを説明することがゴールです; これは特定の問題に対する最先端の答えではありません。
数学的表現 良くある花弁の長さと幅だけでなく、がく片の長さと幅の関数であった場合とその種別について考察します。
したがって $y$ が種別の値であると考える場合に解決すべき方程式は次の通りです:
$$ y = \theta_0 + \theta_1 * sepal\_length + \theta_2 * sepal\_width + \theta_3 * petal\_length + \theta_4 * petal\_width$$
ベクトルを考慮した場合の $x$ と $\Theta$ はこうなります:</description></item><item><title>データフレームからテンソルを作成 (gota)</title><link>https://gorgonia.org/ja/how-to/dataframe/</link><pubDate>Wed, 30 Oct 2019 22:57:09 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/dataframe/</guid><description>このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。
csvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:
sepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。
種別以外のすべての値を含むテンソルを作成します。
gotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。
f, err := os.Open(&amp;#34;iris.csv&amp;#34;) if err != nil { log.Fatal(err) } defer f.</description></item><item><title>Weightsの保存</title><link>https://gorgonia.org/ja/how-to/save-weights/</link><pubDate>Tue, 29 Oct 2019 20:07:16 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/save-weights/</guid><description>ゴール このハウツーのゴールはノードの値を保存して復元する方法を説明することです。
実装 現状できる最善の方法は、対応するノードの値を保存して復元することです。
テンソルはGobEncodeおよびGobDecodeインターフェースを実現しており、これが最良のオプションです。 バックエンドを要素のスライスとして保存することもできますがこれは少し複雑です。
これを行うサンプルコードを以下に示します(まったく最適化していません。自由に修正してください):
package main import ( &amp;#34;encoding/gob&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;gorgonia.org/gorgonia&amp;#34; &amp;#34;gorgonia.org/tensor&amp;#34; ) var ( backup = &amp;#34;/tmp/example_gorgonia&amp;#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // Create the graph x = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;x&amp;#34;)) y = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;y&amp;#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.</description></item><item><title>LispMachine</title><link>https://gorgonia.org/ja/reference/vm/lispmachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>https://gorgonia.org/ja/reference/vm/lispmachine/</guid><description>LispMachine はグラフを入力として受け取るように設計されており、グラフのノードで直接実行されます。 グラフが変更された場合は、単純に新しい軽量 LispMachine を作成して実行します。 LispMachine はサイズが固定されていない recurrent neural networks の作成などのタスクに適しています。
トレードオフとしては LispMachine でのグラフの実行が TapeMachine での実行よりも一般に遅いことです。 グラフの同じ静的な &amp;ldquo;画像&amp;rdquo; が与えられます。</description></item><item><title>Tapemachine</title><link>https://gorgonia.org/ja/reference/vm/tapemachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>https://gorgonia.org/ja/reference/vm/tapemachine/</guid><description>TapeMachine は一般的にに静的な式を実行するのに役立ちます(つまり計算グラフは変更されない)。 静的な性質があるので TapeMachine は一度だけコンパイルされ何度も式を実行するのに向いています(線形回帰や SVM など)。
技術詳細 TapeMachine はインストラクションのリストに対してグラフを事前コンパイルします。 その後、命令を線形に順次実行します。 主なトレードオフはダイナミズムです。 再コンパイルプロセスが必要になるため、グラフを動的に作成することはできません(コンパイルは比較的高価なため)。 ただし、コード生成段階で多くの最適化が行われるため TapeMachine で実行されるグラフははるかに高速に実行されます。</description></item><item><title>数式微分</title><link>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</guid><description>このページは数式微分の仕組みについて説明します</description></item><item><title>自動微分</title><link>https://gorgonia.org/ja/about/differentiation/autodiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/autodiff/</guid><description>このページは自動微分の仕組みについて説明します</description></item></channel></rss>